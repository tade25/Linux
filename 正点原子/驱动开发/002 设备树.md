# 设备树
- Documentation/devicetree/bindings
- 《DeviceTree SpecificationV0.2.pdf》
- 《Power ePAPR_APPROVED_v1.12.pdf》

## 一、设备树概述
### 1.1 设备树的目的
- 描述硬件，而不是描述驱动逻辑
- 将硬件信息从内核代码中剥离
- 同一内核镜像支持多块板子(soc + board解耦)
- 核心思想：驱动 = 通用代码 + 设备树 = 硬件差异

### 1.2 DTS/DTSI的职责划分
|文件类型|作用|
|---|---|
|.dts|板级信息|
|.dtsi|SoC/IP公共信息|
|.dtb|二进制设备树|
|.dtc|Device Tree Compiler|

- 常见结构
```text
soc.dtsi    // SoC公共资源
board.dts   // 板级外设选择 / GPIO / 频率
```

## 二、DTS/DTB/DTC关系
### 2.1 文件关系 
```text
dts + dtsi --(dtc)--> dtb
```
- dts：源码
- dtc：编译工具
- dtb：编译结果(二进制)

### 2.2 dtc位置
- Linux内核源码：scripts/dtc/

### 2.3 编译方式
```bash
make dtbs       # 编译所有dts
make xxx.dtb    # 编译指定的dtb
```

## 3. 设备树语法结构
### 3.1 根节点/
- 所有节点的起点
- 通常包含
    - compatible
    - #address-cells
    - #size-cells
    - chosen
    - aliases
```dts
/ {
    compatible = "vendor,board", "vendor,soc";
};
```

### 3.2 节点命名规则
- label:node_name@unit_address
    - label，标签，可选的，用于&引用
    - node_name，设备类型
    - unit_address，外设寄存器的起始地址，也有可能是I2C的设备节点
```dts
uart0: serial@02020000 {
    ...
};
```

## 四、特殊节点
### 4.1 chosen节点
- 作用
    - 将u-boot中的bootargs环境变量值传递给Linux内核作为命令行参数
```dts
chosen {
    bootargs = "console=ttymxc0,115200 root=/dev/mmcblk0p2 rw";
};
```
- u-boot到内核流程
    - u-boot设置bootargs
    - common/fdt_support.c中有fdt_chosen函数(查找chosen节点，并且添加bootargs)

### 4.2 aliases节点
- 作用
    - 给设备起稳定编号
```dts
aliases {
    serial0 = &uart0;
    ethernet0 = &fec1;
};
```

## 五、设备树的运行时形态
- /proc/device-tree/
    - 与DTS结构一一对应
    - 所有属性都是二进制形式
```bash
ls /proc/device-tree/soc/serial@02020000
```

## 六、标准属性
### 6.1 compatible
- 驱动匹配依据
- 支持从具体->通用的回退机制
```dts
compatible = "fsl,imx6ull-uart", "fsl,imx-uart";
```

### 6.2 #address-cells / #size-cells
- 用于规定子节点的reg属性的格式
```
parent {
    #address-cells = <1>;
    #size-cells = <1>;

    child {
        reg = <0x02020000 0x1000>;
    };
};
```

### 6.3 reg
```dts
reg = <address size>
```
- address / size单元数由父节点决定

### 6.4 ranges
- 总线地址 -> CPU物理地址的映射
```dts
ranges = <bus_addr cpu_addr size>; #很多SoC总线必须有ranges，否则of_iomap失败
```
    - name，弃用
    - device_type，弃用，cpu和memory节点会用到

### 6.5 已弃用属性
|属性||
|---|---|
|name|弃用|
|device-type|cpu和memory节点仍使用|

## 七、根节点compatible的作用
- 早期用于machine匹配
- 现代内核：基本只依赖DT+驱动匹配
```c
DT_MACHINE_START()
```
- 关联
```text
arch/arm/tools/mach-types
```

## 八、内核中的设备树数据结构
### 8.1 struct device_node
```c
struct device_node {
    const char *name;
    const char *type;
    phandle phandle;
    const char *full_name;
    struct property *properties;
    struct device_node *parent;
    struct device_node *child;
    struct device_node *sibling;
};
```

### 8.2 struct property
```c
struct property {
    char *name;
    int length;
    void *value;
    struct property *next;
};
```

## 九、设备节点查找API
- <linux/of.h>

### 9.1 节点查找
| API                     | 说明           |
| ----------------------- | ------------ |
| of_find_node_by_name    | 按 name       |
| of_find_node_by_type    | 按 type       |
| of_find_compatible_node | 按 compatible，最标准最推荐 |
| of_find_node_by_path    | 按路径          |
| of_get_parent           | 父节点          |
| of_get_next_child       | 遍历子节点        |

```c
struct device_node *of_find_compatible_node(
    struct device_node *from,
    const char *type,
    const char *compatible
)

// 失败返回NULL，成功返回查找的节点
```

### 9.2 属性读取API
- 单值
```c
static inline int of_property_read_u32(
    const struct device_node *np,
    const char *propname,
    u32 *out_value
)

/* 示例 */
of_property_read_u32(np, "clock-frequency", &val);
```

- 数组
```c
int of_property_read_u32_array(
    const struct device_node *np,
    const char *propname,
    u32 *out_values,
    size_t sz
)

/* 示例 */
of_property_read_u32_array(np, "reg", arr, n);
```

- 元素个数
```c
int of_property_count_elems_of_size(
    const struct device_node *np,
    const char *propname,
    int elem_size
)

/* 示例 */
of_property_count_elems_of_size(np, "reg", sizeof(u32));
```

### 9.3 地址映射
- of_iomap等价于
    - 解析reg
    - ioremap
```c
void __iomem *of_iomap(struct device_node *node, int index)

/* 示例 */
void __iomem *base = of_iomap(np, 0);
```
