# I2C驱动

- i2c适配器驱动，即SoC的I2C Controller驱动
    - i2c_adapter
        - 如何向内核注册 / 释放的i2c_adpater
        - i2c_algorithm
            - 实现i2c的读写函数，什么master

    - i2c_adapter属于哪个层级？
    - 由platform总线帮忙实现

- i2c_client
    - 在设备树描述，设备树解析的时候自动创建

- i2c_driver

```c
int i2c_register_driver(struct module *owner, struct i2c_driver *driver)

#define i2c_add_driver(driver) \
	i2c_register_driver(THIS_MODULE, driver)

void i2c_del_driver(struct i2c_driver *driver)
```

- 设备树

```c
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
```
- i2c_adapter，可以从probe的i2c_client获取
- i2cmsg
```c
struct i2c_msg {
	__u16 addr;	/* slave address			*/
	__u16 flags;
#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
#define I2C_M_RD		0x0001	/* read data, from slave to master */
#define I2C_M_STOP		0x8000	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_NOSTART */
#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
	__u16 len;		/* msg length				*/
	__u8 *buf;		/* pointer to msg data			*/
};
```

