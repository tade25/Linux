# 并发与竞争

## 一、并发与竞争的核心概念
### 1.1 并发(Concurrency)
- 多个执行流在同一时间段内并行或交错执行
 - Linux中的并发来源：
    - 多进程 / 多线程
    - 中断上下文
    - 内核抢占
    - 多核CPU

### 1.2 竞争(Race Condition)
- 定义
```text
多个执行流在没有同步保护的情况下并发访问共享状态资源，导致执行结果依赖于访问顺序，从而不可预期
```
- 本质
```text
访问顺序不确定 + 状态依赖顺序
```

## 二、共享资源
- 内存状态类资源
    - 共享变量
    - 结构体成员
    - 内核数据结构（链表、队列、树）
    - 计数器、标志位

- 硬件状态类资源
    - 设备寄存器（MMIO / IO Port）
    - GPIO / DMA / UART 控制寄存器
    - 设备内部状态机

- 逻辑状态类资源
    - 设备是否已打开
    - 当前工作模式
    - 文件偏移量
    - 是否正在传输

## 三、临界区
临界区不是资源本身，而是并发执行流访问共享状态资源时，必须互斥执行的那段代码路径

## 四、竞争的示例
在并发情况下，counter++并非原子操作，实际是：(1) 读取counter (2)加1 (3) 写回counter
如果两个线程同时执行，可能只加 1 次

## 五、解决并发与竞争

### 5.1 原子操作
- 基本概念
    - CPU 指令级保证原子性，用于简单操作
    - 不会睡眠

- 常用API
```c
<linux/atomic.h>

typedef struct {
    int counter;
} atomic_t;

void atomic_set(atomic_t *v, int i);
int  atomic_read(const atomic_t *v);

void atomic_inc(atomic_t *v);
void atomic_dec(atomic_t *v);

int atomic_inc_return(atomic_t *v);
int atomic_dec_and_test(atomic_t *v);
```

- 示例
```c
static atomic_t refcnt = ATOMIC_INIT(0);

void device_get(void)
{
    atomic_inc(&refcnt);
}

void device_put(void)
{
    if (atomic_dec_and_test(&refcnt)) {
        /* refcnt == 0，安全释放资源 */
        cleanup_device();
    }
}
```

- 适用场景
    - 原子性
    - 不涉及休眠 / 唤醒

### 5.2 自旋锁
- 基本概念
    - 获取不到锁时一直等，所以持锁时间必须极短
    - 不会睡眠

- 常用API
```c
<linux/spinlock.h>

typedef struct spinlock spinlock_t;
void spin_lock_init(spinlock_t *lock);

void spin_lock(spinlock_t *lock);
void spin_unlock(spinlock_t *lock);

void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
```

- 示例
```c
static spinlock_t lock;
static int counter;

void update_counter(void)
{
    unsigned long flags;

    spin_lock_irqsave(&lock, flags);
    counter++;
    spin_unlock_irqrestore(&lock, flags);
}
```

- 适用场景
    - 多CPU并发访问
    - 中断上下文并发
    - 提供互斥

### 5.3 信号量
- 基本概念
    - 基于计数的同步机制
    - 获取不到资源时睡眠

- 常用API
```c
<linux/semaphore.h>

struct semaphore;

void sema_init(struct semaphore *sem, int val);

void down(struct semaphore *sem);
int  down_interruptible(struct semaphore *sem);

void up(struct semaphore *sem);

```

- 示例
```c
static struct semaphore sem;

void init(void)
{
    sema_init(&sem, 3);   // 最多允许3个并发
}

void access_resource(void)
{
    down(&sem);           //可能睡眠
    do_work();
    up(&sem);
}
```

- 适用场景
    - 资源数量控制
    - 阻塞与唤醒
    - 提供的是同步

### 5.4 互斥体
- 基本概念
    - 二值信号量的语义化版本，同一时间只允许一个执行流进入
    - 必须由加锁者解锁

- 常用API
```c
struct mutex;

void mutex_init(struct mutex *lock);

void mutex_lock(struct mutex *lock);
int  mutex_trylock(struct mutex *lock);
void mutex_unlock(struct mutex *lock);

```

- 示例
```c
static struct mutex lock;
static int device_opened;

int device_open(void)
{
    mutex_lock(&lock);
    if (device_opened) {
        mutex_unlock(&lock);
        return -EBUSY;
    }
    device_opened = 1;
    mutex_unlock(&lock);
    return 0;
}
```

- 适用场景
    - 互斥访问
    - 睡眠等待

### 六、自旋锁死锁的原因与避免
- 常见死锁原因
    - 重复加锁（自锁）
    - 中断上下文与进程上下文争同一把锁
    - 多锁顺序不一致
    - 持锁时间过长

- 避免原则
    - 持锁时间要短
    - 不在自旋锁内睡眠
    - 中断相关场景使用spin_lock_irqsave
    - 全局统一加锁顺序
