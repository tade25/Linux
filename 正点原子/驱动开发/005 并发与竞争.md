# 并发与竞争

## 一、并发与竞争的核心概念
### 1.1 并发(Concurrency)
- 多个执行流在同一时间段内并行或交错执行
 - Linux中的并发来源：
    - 多进程 / 多线程
    - 中断上下文
    - 内核抢占
    - 多核CPU

### 1.2 竞争(Race Condition)
- 定义
```text
多个执行流在没有同步保护的情况下并发访问共享状态资源，导致执行结果依赖于访问顺序，从而不可预期
```
- 本质
```text
访问顺序不确定 + 状态依赖顺序
```

## 二、共享资源
- 内存状态类资源
    - 共享变量
    - 结构体成员
    - 内核数据结构（链表、队列、树）
    - 计数器、标志位

- 硬件状态类资源
    - 设备寄存器（MMIO / IO Port）
    - GPIO / DMA / UART 控制寄存器
    - 设备内部状态机

- 逻辑状态类资源
    - 设备是否已打开
    - 当前工作模式
    - 文件偏移量
    - 是否正在传输

## 三、临界区
临界区不是资源本身，而是并发执行流访问共享状态资源时，必须互斥执行的那段代码路径

## 四、竞争的示例
在并发情况下，counter++并非原子操作，实际是：(1) 读取counter (2)加1 (3) 写回counter
如果两个线程同时执行，可能只加 1 次

## 五、解决并发与竞争

### 5.1 原子操作
- 基本概念
    - CPU 指令级保证原子性，用于简单操作
    - 不会睡眠

- 常用API
```c
<linux/atomic.h>

typedef struct {
    int counter;
} atomic_t;

void atomic_set(atomic_t *v, int i);
int  atomic_read(const atomic_t *v);

void atomic_inc(atomic_t *v);
void atomic_dec(atomic_t *v);

int atomic_inc_return(atomic_t *v);
int atomic_dec_and_test(atomic_t *v);
```

- 示例
```c
static atomic_t refcnt = ATOMIC_INIT(0);

void device_get(void)
{
    atomic_inc(&refcnt);
}

void device_put(void)
{
    if (atomic_dec_and_test(&refcnt)) {
        /* refcnt == 0，安全释放资源 */
        cleanup_device();
    }
}
```

- 适用场景
    - 原子性
    - 不涉及休眠 / 唤醒

### 5.2 自旋锁
- 基本概念
    - 互斥的方式
    - 获取不到锁时一直等，所以持锁时间必须极短，不可以休眠
    - 自旋锁会自动禁止抢占

- 常用API
```c
<linux/spinlock.h>

typedef struct spinlock spinlock_t;
void spin_lock_init(spinlock_t *lock);

void spin_lock(spinlock_t *lock);
void spin_unlock(spinlock_t *lock);

/* 如果线程和中断用到了共享资源，用这个 */
void spin_lock_irqsave(spinlock_t *lock, unsigned long flags);
void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);
```

- 示例
```c
static spinlock_t lock;
static int counter;

void update_counter(void)
{
    unsigned long flags;

    spin_lock_irqsave(&lock, flags);
    counter++;
    spin_unlock_irqrestore(&lock, flags);
}
```

- 适用场景
    - SMP / 支持抢占的单CPU下线程之间的并发访问
    - 中断上下文并发

- 常见死锁原因
    - 递归申请自旋锁（自锁）
    - 中断上下文与进程上下文争同一把锁
    - 多锁顺序不一致
    - 持锁时间过长

- 自旋锁使用注意事项
    - 持锁时间要短，否则会降低系统性能；如果临界区比较大，选择信号量 / 互斥体
    - 不要在自旋锁保护的临界区睡眠
    - 全局统一加锁顺序

### 5.3 信号量
- 基本概念
    - 基于计数的同步机制
    - 获取不到资源时睡眠

- 常用API
```c
<linux/semaphore.h>

struct semaphore {
    raw_spinlock_t      lock;
    unsigned int        count;
    struct list_head    wait_list;
};

/* 初始化一个信号量，设置信号量值为val */
void sema_init(struct semaphore *sem, int val);

/* 获取信号量 */
void down(struct semaphore *sem);

/* 尝试获取信号量，获取到返回0，否则返回非0，并且不会休眠 */
int down_trylock(struct semaphore)

/* 与down类似，不过此函数进入休眠以后时可以被信号打断的 */
int  down_interruptible(struct semaphore *sem);

/* 释放信号量 */
void up(struct semaphore *sem);

```

- 示例
```c
static struct semaphore sem;

void init(void)
{
    sema_init(&sem, 3);   // 最多允许3个并发
}

void access_resource(void)
{
    down(&sem);         // 可能睡眠
    do_work();          // 临界区     
    up(&sem);
}
```

- 适用场景
    - 资源占用比较久的场合
    - 控制资源访问数量

- 信号量使用注意事项
    - 信号量不能用于中断中，因为获取不到资源时会休眠，而中断中不能休眠
    - 临界区比较小的情况，不适合信号量

### 5.4 互斥体
- 基本概念
    - 二值信号量的语义化版本，同一时间只允许一个执行流进入
    - 必须由加锁者解锁

- 常用API
```c
struct mutex {
    atomic_t    count;
    spinlock_t  wait_lock;
};

/* 初始化mutex */
void mutex_init(struct mutex *lock);

/* 获取mutex，给mutex上锁，获取不到就休眠 */
void mutex_lock(struct mutex *lock);

/* 与mutex_lock相似，此函数获取信号量失败进入休眠后可以被信号打断 */
int mutex_lock_interruptible(struct mutex* lock)

/* 释放mutex，给mutex解锁 */
void mutex_unlock(struct mutex *lock);

/* 尝试获取mutex，1(成功) / 0(失败) */
int  mutex_trylock(struct mutex *lock);

/* 判断mutex是否被获取，如果是的话就返回1，否则返回0*/
int mutex_is_locked(struct mutex* lock);
```

- 示例
```c
static struct mutex lock;
static int device_opened;

int device_open(void)
{
    mutex_lock(&lock);
    if (device_opened) {
        mutex_unlock(&lock);
        return -EBUSY;
    }
    device_opened = 1;
    mutex_unlock(&lock);
    return 0;
}
```

- 适用场景
    - 互斥访问
    - 睡眠等待
